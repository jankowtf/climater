---
title: "climater app"
author: "Janko Thyson"
date: '2018-04-12'
output: html_document
runtime: shiny
subtitle: v0.0.0.9002
resource_files:
- data/tidy/db_v3.rds
- data/tidy/db_v3.rds
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# install.packages("shiny")
# install.packages("DT")
library(shiny)
options(shiny.suppressMissingContextError = TRUE)
library(DT)
if (basename(here::here()) == "climater") {
  devtools::load_all(here::here())
} else {
  library(climater)  
}

settings <- default_settings()
settings$output$show <- FALSE
set_global_data_repo("repo_1", settings = settings)
# set_global_data_repo("repo_2", settings = settings)

if (basename(here::here()) == "climater") {
  source(here::here("inst/app/4-load.R"))
} else {
  source("4-load.R")  
}
dat_db_0 <- data_read_db(vsn = "v3")
```

## Inputs

Note:

* `Distance measures` controls on which distance measures the "raw" prediction is based. By default, all distance measures are used, but you can select the ones you want.
* `Distance measure for ensemble` controls which *single* distance measure should be used in order to produce an "ensemble" prediction (most frequent rank)
* If only one distance measure is specified in `Distance measure`, then the ensemble predictions are identical to the raw predicitons.

```{r frontend, echo=FALSE}
dat_distance <- reactive({
  dat_geo <- data.frame(
    dim_latitude = ifelse(is.null(v <- input$lat), 1, v),
    dim_longitude = ifelse(is.null(v <- input$long), 1, v)
  )
  compute_geo_distance_v2(p_1 = dat_geo, p_2 = dat_station) %>%
    dplyr::pull(msr_distance) %>% round(2)
})
dist_measure <- "euclidean"
dist_measure_final <- dist_measure

inputPanel(
  selectInput("time_month", label = "Month of year",
    choices = 1:12, selected = 7),
  
  sliderInput("msr_temp_min", label = "Min. temperature",
    min = min(dat_db_0$msr_temp_min, na.rm = TRUE) %>% floor(), 
    max = max(dat_db_0$msr_temp_min, na.rm = TRUE) %>% ceiling(), 
    value = mean(dat_db_0$msr_temp_min, na.rm = TRUE), step = 0.5),
  
  sliderInput("msr_temp_max", label = "Max. temperature",
    min = min(dat_db_0$msr_temp_max, na.rm = TRUE) %>% floor(),
    max = max(dat_db_0$msr_temp_max, na.rm = TRUE) %>% ceiling(), 
    value = mean(dat_db_0$msr_temp_min, na.rm = TRUE), step = 0.5),
  
  # sliderInput("msr_temp_avg", label = "Avg. temperature",
  #   min = min(dat_db_0$msr_temp_avg, na.rm = TRUE) %>% floor(), 
  #   max = max(dat_db_0$msr_temp_avg, na.rm = TRUE) %>% ceiling(), 
  #   value = mean(dat_db_0$msr_temp_avg, na.rm = TRUE), step = 0.5),
  
  # sliderInput("msr_precip_min", label = "Min. precipitation",
  #   min = min(dat_db_0$msr_precip_min, na.rm = TRUE) %>% floor(), 
  #   max = max(dat_db_0$msr_precip_min, na.rm = TRUE) %>% ceiling(), 
  #   value = mean(dat_db_0$msr_precip_min, na.rm = TRUE), step = 0.5),
  # 
  # sliderInput("msr_precip_max", label = "Max. precipitation",
  #   min = min(dat_db_0$msr_precip_max, na.rm = TRUE) %>% floor(),
  #   max = max(dat_db_0$msr_precip_max, na.rm = TRUE) %>% ceiling(),
  #   # value = mean(dat_db_0$msr_precip_min, na.rm = TRUE), 
  #   value = 10,
  #   step = 0.5),
  
  sliderInput("msr_precip_avg", label = "Rain days per month",
    min = min(dat_db_0$msr_precip_avg, na.rm = TRUE) %>% floor(),
    max = max(dat_db_0$msr_precip_avg, na.rm = TRUE) %>% ceiling(), 
    value = 10, step = 1),
  
  sliderInput("msr_sundur_avg", label = "Sunshine hours per day",
    # min = min(dat_db_0$msr_sundur_avg, na.rm = TRUE) %>% floor(), 
    min = 0, 
    # max = max(dat_db_0$msr_sundur_avg, na.rm = TRUE) %>% ceiling(),
    max = 28,
    value = mean(dat_db_0$msr_sundur_avg, na.rm = TRUE), step = 4),
  
  sliderInput("msr_distance", label = "Distance to destination",
    min = 0,
    max = 1000,
    value = 100, step = 1),
  
  shiny::checkboxGroupInput("msr_inputs_chosen", label = "Choose inputs to use",
    choices = c(
      "time_month", 
      "msr_temp_min", 
      "msr_temp_max",
      # "msr_temp_avg",
      # "msr_precip_min", 
      # "msr_precip_max",
      "msr_precip_avg",
      "msr_sundur_avg",
      "msr_distance"
    ),
    selected = c("time_month", "msr_temp_avg")
  ),
  
  selectInput("knn", label = "Number of recommendations",
    choices = 1:10, selected = 3),
  
  # selectInput("dist_measures", label = "Distance measures",
  #   choices = default_dist_measures(), selected = 1, multiple = TRUE),
  
  # selectInput("dist_measure_final", label = "Distance measures for ensemble",
  #   choices = default_dist_measures(), selected = 1),
  
  actionButton("do", "Submit", icon = icon("refresh")),
  
  # JS for automatic detection of geo location 
  # Source: https://github.com/AugustT/shiny_geolocation
  tags$script('
      $(document).ready(function () {
        navigator.geolocation.getCurrentPosition(onSuccess, onError);
              
        function onError (err) {
          Shiny.onInputChange("geolocation", false);
        }
              
        function onSuccess (position) {
          setTimeout(function () {
            var coords = position.coords;
            console.log(coords.latitude + ", " + coords.longitude);
            Shiny.onInputChange("geolocation", true);
            Shiny.onInputChange("lat", coords.latitude);
            Shiny.onInputChange("long", coords.longitude);
          }, 1100)
        }
      });
              ')
)

observe({
  input$lat
  updateSliderInput(session, "msr_distance",
    value = mean(dat_distance(), na.rm = TRUE),
    min = min(dat_distance(), na.rm = TRUE),
    max = max(dat_distance(), na.rm = TRUE),
    step = 1
  )
})

dat_input_rea <- reactive({
  dat <- data.frame(
    dim_latitude = ifelse(is.null(v <- input$lat), 0, as.numeric(v)),
    dim_longitude = ifelse(is.null(v <- input$long), 0, as.numeric(v)),
    time_month = as.numeric(input$time_month),
    msr_temp_min = as.numeric(input$msr_temp_min),
    msr_temp_max = as.numeric(input$msr_temp_max),
    # msr_temp_avg = as.numeric(input$msr_temp_avg),
    # msr_precip_min = as.numeric(input$msr_precip_min),
    # msr_precip_max = as.numeric(input$msr_precip_max),
    msr_precip_avg = as.numeric(input$msr_precip_avg),
    msr_sundur_avg = as.numeric(input$msr_sundur_avg),
    msr_distance = as.numeric(input$msr_distance)
  ) 
  
  msr_inputs_chosen <- input$msr_inputs_chosen
  msr_inputs_chosen <- c("dim_latitude", "dim_longitude", msr_inputs_chosen)
  dat[ , msr_inputs_chosen]
})

dat_output_rea <- eventReactive(input$do, {
  dat_input <- dat_input_rea()
  knn <- as.numeric(input$knn)
  dist_measures <- input$dist_measures
  dist_measure_final <- input$dist_measure_final
  
  if (basename(here::here()) == "climater") {
    source(here::here("inst/app/6-model.R"), local = TRUE)
  } else {
    source("6-model.R", local = TRUE)
  }
  
  model_result_gathered
})
```

## Outputs {.tabset}

```{r echo=FALSE, eval=FALSE}
### Ensemble prediction table
renderDataTable({
  dat_output_rea()$prediction_ensemble
}, options = list(scrollX = TRUE))
```

### Prediction table

```{r echo=FALSE}
renderDataTable({
  dat_output_rea()$prediction
}, options = list(scrollX = TRUE))
```

### Input table

```{r echo=FALSE}
renderDataTable({
  dat_output_rea()$input
}, options = list(scrollX = TRUE))

```

### Geo location

#### Latitude

```{r output-lat, echo = FALSE}
renderPrint({
  input$lat
})
```

#### Longitude

```{r output-long, echo = FALSE}
renderPrint({
  input$long
})
```

#### Geo location

```{r output-geoloc, echo = FALSE}
renderPrint({
  input$geolocation
})
```

#### Distances (summary)

```{r output-dists, echo = FALSE}
renderPrint({
  dat_distance() %>% summary()
})
```
